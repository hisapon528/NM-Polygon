<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ê≠£ N/M ËßíÂΩ¢</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">

  <style>
    :root{
      /* Theme vars (default: dark) */
      --bg:#0b0f17;
      --bgImg: radial-gradient(1200px 700px at 30% 20%, rgba(17,24,39,1), rgba(5,7,11,1));
      --fg:#e5e7eb;
      --muted:#9ca3af;

      --panel: rgba(17,24,39,.86);
      --panelSolid:#111827;

      --border: rgba(255,255,255,.10);
      --border2: rgba(255,255,255,.14);

      /* Buttons */
      --btnBg: rgba(255,255,255,.06);
      --btnBgHover: rgba(255,255,255,.10);
      --btnBorder: rgba(255,255,255,.14);

      /* controls/boxes */
      --controlsBg: linear-gradient(to bottom, var(--panelSolid), rgba(17,24,39,.60));
      --boxBg: rgba(0,0,0,.18);
      --cardBg: rgba(255,255,255,.04);

      /* Canvas */
      --canvasBg: rgba(0,0,0,0); /* actual fill done in JS */
      --circle: rgba(255,255,255,.18);

      /* HUD box */
      --hudBg: rgba(0,0,0,.55);
      --hudFg: rgba(255,255,255,.92);
      --hudBorder: rgba(255,255,255,.18);

      /* Modal vars (dark default) */
      --overlayBg: rgba(0,0,0,.55);
      --modalBg: rgba(17,24,39,.96);
      --modalBorder: rgba(255,255,255,.10);
      --modalBodyBg: rgba(0,0,0,.18);
      --modalRowBg: rgba(255,255,255,.03);
      --modalRowBorder: rgba(255,255,255,.08);
      --inputBg: rgba(0,0,0,.25);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic",sans-serif;
      background-color: var(--bg);
      background-image: var(--bgImg);
      color:var(--fg);
      overflow:hidden;
    }

    .wrap{
      display:grid;
      grid-template-columns: 440px 1fr;
      height:100vh;
      width:100vw;
    }

    /* Left panel scroll only */
    .panel{
      height:100vh;
      overflow-y:auto;
      padding:16px;
      background: var(--panel);
      border-right: 1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(8px);
    }

    h1{ font-size:18px; margin:0 0 10px; }
    .desc{
      font-size:12px; color:var(--muted); line-height:1.55; margin-bottom:12px;
    }

    .controlsTop{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin:10px 0 14px;
      position: sticky; top: 0; z-index: 5;
      padding: 10px 0;
      background: var(--controlsBg);
      border-bottom: 1px solid rgba(255,255,255,.06);
      box-shadow:none;
      backdrop-filter:none;
    }

    button{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--btnBorder);
      background: var(--btnBg);
      color:var(--fg);
      cursor:pointer;
      user-select:none;
    }
    button:hover{ background: var(--btnBgHover); }

    .btnPrimary{ border-color: rgba(96,165,250,.55); }
    .btnToggle { border-color: rgba(52,211,153,.45); }
    .btnWarn   { border-color: rgba(251,191,36,.55); }

    .rows{
      display:flex; flex-direction:column; gap:10px;
      padding:10px;
      border:1px solid var(--border);
      border-radius:14px;
      background: var(--boxBg);
      margin-bottom: 12px;
    }

    .rowCard{
      display:grid;
      grid-template-columns: 1fr 1fr auto auto auto;
      gap:8px;
      align-items:center;
      padding:10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background: var(--cardBg);
      box-shadow:none;
    }
    .rowCard .label{
      font-size:11px; color:var(--muted); margin-bottom:4px;
    }
    .rowCard .field{ display:flex; flex-direction:column; }

    input[type="number"]{
      width:100%;
      padding:10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background: var(--inputBg);
      color:var(--fg);
      outline:none;
    }

    .iconBtn{
      width:40px; height:40px;
      display:inline-flex; align-items:center; justify-content:center;
      border-radius:12px;
      border:1px solid var(--border2);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      font-size:16px;
      color: var(--fg);
      box-shadow:none;
    }
    .iconBtn:hover{ background: rgba(255,255,255,.10); }

    .swatch{
      width:14px; height:14px; border-radius:6px;
      border:1px solid rgba(255,255,255,.25);
      display:inline-block;
      vertical-align:middle;
      margin-left:6px;
    }
    .rowMeta{
      grid-column: 1 / -1;
      font-size:11px;
      color: var(--muted);
      margin-top:4px;
      line-height:1.55;
    }

    .globalBox{
      margin-top:12px;
      padding:12px;
      border:1px solid var(--border);
      border-radius:14px;
      background: var(--boxBg);
      font-size:12px;
      line-height:1.65;
      color: var(--muted);
      box-shadow:none;
    }
    .globalBox b{ color:var(--fg); }

    /* Right side fixed center */
    .canvasWrap{
      height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .square{
      width: min(940px, calc(100vw - 490px));
      aspect-ratio: 1 / 1;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      background: transparent;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden;
    }
    canvas{ width:100%; height:100%; display:block; cursor: grab; }
    canvas.dragging{ cursor: grabbing; }

    /* Modal */
    .modalOverlay{
      position:fixed; inset:0;
      background: var(--overlayBg);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index: 1000;
    }
    .modal{
      width:min(580px, 96vw);
      background: var(--modalBg);
      border:1px solid var(--modalBorder);
      border-radius:18px;
      padding:14px;
      box-shadow: var(--shadow);
    }
    .modalHeader{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; margin-bottom:10px;
    }
    .modalTitle{ font-size:14px; font-weight:700; }
    .closeBtn{
      width:38px; height:38px; border-radius:12px;
      border:1px solid var(--border2);
      background: rgba(255,255,255,.06);
      color:var(--fg); cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      font-size:16px;
    }
    .closeBtn:hover{ background: rgba(255,255,255,.10); }

    .modalBody{
      display:flex; flex-direction:column; gap:10px;
      padding:10px;
      border:1px solid var(--modalRowBorder);
      border-radius:14px;
      background: var(--modalBodyBg);
      font-size:12px;
    }
    .modalRow{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:8px 8px;
      border-radius:12px;
      border:1px solid var(--modalRowBorder);
      background: var(--modalRowBg);
    }
    .modalRow .left{ color: var(--fg); }
    .modalRow .right{ display:flex; gap:8px; align-items:center; }

    input[type="color"]{
      width:44px; height:32px;
      border:none; background: transparent; padding:0;
      cursor:pointer;
    }
    .miniInput{
      width: 150px;
      padding:8px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background: var(--inputBg);
      color: var(--fg);
      outline:none;
      font-size: 12px;
    }

    .tiny{
      font-size:11px;
      color: var(--muted);
      line-height: 1.5;
      margin-top: 8px;
    }
    .footerNote{
      margin-top:10px;
      font-size:11px;
      color:var(--muted);
      line-height:1.55;
      padding-bottom: 16px;
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="panel">
    <h1>Ê≠£ N/M ËßíÂΩ¢</h1>
    <div class="desc">
      ÂÜÜÂë®‰∏ä„Çí <b>N</b> Á≠âÂàÜ„Åó„ÅüÁÇπ„Çí„ÄÅ<b>M</b> ÂÄã„Å®„Å∞„Åó„ÅßËæø„Çä„Åæ„Åô„ÄÇ<br/>
      ‰ΩúÂõ≥„ÅØ <b>ÂßãÁÇπÔºàstartÔºâ</b> „ÇíÂü∫Ê∫ñ„Å´„Åó„ÄÅ<b>ÂßãÁÇπ„Å´Êàª„Å£„ÅüÁû¨Èñì„Å´ÁµÇ‰∫Ü</b>„Åó„Åæ„Åô„ÄÇ<br/>
      Âõ≥ÂΩ¢„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®„ÄÅÊèèÁîªÂ∑¶‰∏ä„Å´„Åù„ÅÆÂõ≥ÂΩ¢„ÅÆ <b>N/M</b> „ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ
    </div>

    <div class="controlsTop">
      <button id="addRow" class="btnPrimary">Ôºã ËøΩÂä†</button>
      <button id="resetAll" class="btnWarn">„É™„Çª„ÉÉ„Éà</button>
      <button id="openGlobal" class="btnWarn">Ë®≠ÂÆö</button>
      <button id="toggleAll" class="btnToggle">‚ñ∂ ÂÖ®„Ç¢„Éã„É°ÂÜçÁîü</button>
      <button id="saveAll">„Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà‰øùÂ≠òÔºàPNGÔºâ</button>
    </div>

    <div class="rows" id="rows"></div>
    <div class="globalBox" id="globalInfo"></div>

    <div class="footerNote">
      ‚Äª M „ÅØÂÜÖÈÉ®„Åß <b>M mod N</b>„ÄÅÂßãÁÇπ„ÅØ <b>start mod N</b> „Å´Ê≠£Ë¶èÂåñ„ÄÇ<br/>
    </div>
  </div>

  <div class="canvasWrap">
    <div class="square">
      <canvas id="cv"></canvas>
    </div>
  </div>
</div>

<!-- Ë°åË®≠ÂÆö„É¢„Éº„ÉÄ„É´ -->
<div class="modalOverlay" id="rowModalOverlay">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHeader">
      <div class="modalTitle" id="rowModalTitle">Ë®≠ÂÆö</div>
      <button class="closeBtn" id="rowModalClose" title="Èñâ„Åò„Çã">‚úï</button>
    </div>

    <div class="modalBody">
      <div class="modalRow">
        <div class="left">„Åì„ÅÆÂõ≥ÂΩ¢„ÇíË°®Á§∫</div>
        <div class="right"><input type="checkbox" id="optVisible"></div>
      </div>

      <div class="modalRow">
        <div class="left">È†ÇÁÇπ„ÇíË°®Á§∫</div>
        <div class="right"><input type="checkbox" id="optShowPoints"></div>
      </div>

      <div class="modalRow">
        <div class="left">È†ÇÁÇπÁï™Âè∑„ÇíË°®Á§∫</div>
        <div class="right"><input type="checkbox" id="optShowLabels"></div>
      </div>

      <div class="modalRow">
        <div class="left">È†ÇÁÇπÁï™Âè∑„Çµ„Ç§„Ç∫ÔºàpxÔºâ</div>
        <div class="right">
          <input class="miniInput" type="number" id="optLabelSize" min="8" step="1" />
        </div>
      </div>

      <div class="modalRow">
        <div class="left">Á∑ö„ÅÆËâ≤</div>
        <div class="right"><input type="color" id="optLineColor"></div>
      </div>

      <div class="modalRow">
        <div class="left">È†ÇÁÇπ„ÅÆËâ≤</div>
        <div class="right"><input type="color" id="optPointColor"></div>
      </div>

      <div class="modalRow">
        <div class="left">„Ç¢„Éã„É°ÊôÇÈñìÔºàÁßíÔºâ</div>
        <div class="right">
          <input class="miniInput" type="number" id="optAnimTime" min="0.2" step="0.1" />
        </div>
      </div>

      <div class="modalRow">
        <div class="left">ÂßãÁÇπÔºàstartÔºâ</div>
        <div class="right">
          <input class="miniInput" type="number" id="optStart" step="1" />
        </div>
      </div>

      <div class="tiny">
        ‚ÄªÂßãÁÇπ„ÅØÂÜÖÈÉ®„Åß <b>start mod N</b> „Å´Ê≠£Ë¶èÂåñ„Åô„Çã„ÄÇ<br/>
        ‚ÄªÈ†ÇÁÇπÁï™Âè∑„ÅØËÉåÊôØ„Å´Âøú„Åò„Å¶Ë¶ã„ÇÑ„Åô„ÅÑËâ≤ÔºàËá™ÂãïÔºâ„ÅßÊèèÁîª„Åó„Åæ„Åô„ÄÇ<br/>
      </div>
    </div>
  </div>
</div>

<!-- ÂÖ®‰ΩìË®≠ÂÆö„É¢„Éº„ÉÄ„É´ -->
<div class="modalOverlay" id="globalModalOverlay">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="modalHeader">
      <div class="modalTitle">ÂÖ®‰ΩìË®≠ÂÆö</div>
      <button class="closeBtn" id="globalModalClose" title="Èñâ„Åò„Çã">‚úï</button>
    </div>

    <div class="modalBody">
      <div class="modalRow">
        <div class="left">ËÉåÊôØ</div>
        <div class="right">
          <select id="optTheme" class="miniInput" style="width:170px">
            <option value="dark">„ÉÄ„Éº„ÇØ„É¢„Éº„Éâ</option>
            <option value="light">„É©„Ç§„Éà„É¢„Éº„Éâ</option>
          </select>
        </div>
      </div>

      <div class="modalRow">
        <div class="left">Â§ñÊé•ÂÜÜ„ÅÆËâ≤</div>
        <div class="right">
          <input type="color" id="optCircleColor">
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const rowsEl = document.getElementById('rows');
  const globalInfoEl = document.getElementById('globalInfo');

  const btnAdd = document.getElementById('addRow');
  const btnReset = document.getElementById('resetAll');
  const btnToggleAll = document.getElementById('toggleAll');
  const btnSave = document.getElementById('saveAll');
  const btnOpenGlobal = document.getElementById('openGlobal');

  // Row modal
  const rowModalOverlay = document.getElementById('rowModalOverlay');
  const rowModalTitle = document.getElementById('rowModalTitle');
  const rowModalClose = document.getElementById('rowModalClose');
  const optVisible = document.getElementById('optVisible');
  const optShowPoints = document.getElementById('optShowPoints');
  const optShowLabels = document.getElementById('optShowLabels');
  const optLabelSize = document.getElementById('optLabelSize');
  const optLineColor = document.getElementById('optLineColor');
  const optPointColor = document.getElementById('optPointColor');
  const optAnimTime = document.getElementById('optAnimTime');
  const optStart = document.getElementById('optStart');

  // Global modal
  const globalModalOverlay = document.getElementById('globalModalOverlay');
  const globalModalClose = document.getElementById('globalModalClose');
  const optTheme = document.getElementById('optTheme');
  const optCircleColor = document.getElementById('optCircleColor');

  const TAU = Math.PI * 2;

  // Âõ≥ÂΩ¢„Ç™„Éï„Çª„ÉÉ„Éà
  const DEFAULT_CENTER_Y_OFFSET_CSS = 60;
  let centerYOffsetPx = 0;

  // Defaults
  const DEFAULT_ANIM_TIME = 8.0;
  const DEFAULT_START = 0;
  const DEFAULT_LABEL_SIZE = 22; 

  const palette = [
    "#60a5fa", "#f472b6", "#34d399", "#f59e0b", "#a78bfa",
    "#22d3ee", "#fb7185", "#84cc16", "#e879f9", "#f87171",
  ];

  // ===== View (zoom/pan) =====
  const view = {
    scale: 1.0,
    panX: 0.0,
    panY: 0.0,
    minScale: 0.2,
    maxScale: 20.0,
  };

  function resetView(){
    view.scale = 1.0;
    view.panX = 0.0;
    view.panY = 0.0;
  }

  // ===== Math helpers =====
  function gcd(a,b){
    a = Math.abs(a); b = Math.abs(b);
    while(b !== 0){ const t = a % b; a = b; b = t; }
    return a;
  }
  function mod(n, m){
    return ((n % m) + m) % m;
  }
  function normalizeStep(N, M){
    return mod(M, N);
  }
  function normalizeStart(N, start){
    return mod(start, N);
  }

  function pointsOnCircle(N, cx, cy, r){
    const pts = [];
    for(let k=0;k<N;k++){
      const ang = -Math.PI/2 + TAU*(k/N);
      pts.push({ x: cx + r*Math.cos(ang), y: cy + r*Math.sin(ang) });
    }
    return pts;
  }

  function buildCycle(N, step, start){
    const s = normalizeStart(N, start);
    const seq = [s];
    if (N <= 0 || step === 0) return seq;
    let cur = s;
    const seen = new Set([cur]);
    while(true){
      cur = (cur + step) % N;
      seq.push(cur);
      if(cur === s) break;
      if (seen.has(cur)) break;
      seen.add(cur);
      if (seq.length > N + 2) break;
    }
    return seq;
  }

  // ===== Canvas sizing =====
  function resizeCanvasToDisplaySize(){
    const dpr = window.devicePixelRatio || 1;
    const rect = cv.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if (cv.width !== w || cv.height !== h){
      cv.width = w;
      cv.height = h;
    }

    centerYOffsetPx = Math.round(DEFAULT_CENTER_Y_OFFSET_CSS * dpr);
    ctx.setTransform(1,0,0,1,0,0);
  }

  // ===== Row state =====
  let nextId = 1;
  const rows = [];
  let rafId = null;
  let lastT = null;
  let globalPlaying = false;

  let selectedRowId = null;

  function newRowDefaults(){
    const idx = rows.length;
    const base = palette[idx % palette.length];
    return {
      id: nextId++,
      N: null,
      M: null,

      start: DEFAULT_START,
      animTimeSec: DEFAULT_ANIM_TIME,

      visible: true,
      showPoints: true,
      showLabels: false,

      labelSizePx: DEFAULT_LABEL_SIZE,

      lineColor: base,
      pointColor: base,

      animPlaying: false,
      animProgressEdges: 0.0,
      animSpeedEdgesPerSec: 0.0,
    };
  }

  function rowTitle(r){
    const n = (r.N == null ? "" : r.N);
    const m = (r.M == null ? "" : r.M);
    return `#${r.id}  N=${n}, M=${m}`;
  }

  function getCycleInfo(r){
    const N = r.N, M = r.M;
    if (!Number.isInteger(N) || !Number.isInteger(M) || N < 3 || M < 1) {
      return { edges: 0, step: 0, L: 0, d: 0, startN: 0, cycle: [0], valid:false };
    }

    const step = normalizeStep(N, M);
    const startN = normalizeStart(N, r.start);
    if (step === 0) {
      return { edges: 0, step, L: 0, d: gcd(N, step), startN, cycle: [startN], valid:true };
    }
    const cycle = buildCycle(N, step, startN);
    const edges = Math.max(0, cycle.length - 1);
    const d = gcd(N, step);
    const L = edges;
    return { edges, step, L, d, startN, cycle, valid:true };
  }

  function prepareSpeedsForAll(){
    const validRows = rows.filter(r => getCycleInfo(r).valid && getCycleInfo(r).edges > 0);
    const times = validRows.map(r => Math.max(0.2, Number(r.animTimeSec) || DEFAULT_ANIM_TIME));
    const Tglobal = times.length ? Math.max(...times) : DEFAULT_ANIM_TIME;

    for (const r of rows){
      const info = getCycleInfo(r);
      const edges = info.edges;
      r.animProgressEdges = 0.0;
      r.animSpeedEdgesPerSec = (info.valid && edges > 0) ? (edges / Tglobal) : 0.0;
    }
  }

  // ===== UI rows =====
  function createRowUI(r){
    const card = document.createElement('div');
    card.className = 'rowCard';
    card.dataset.rowId = String(r.id);

    const fieldN = document.createElement('div');
    fieldN.className = 'field';
    fieldN.innerHTML = `<div class="label">N</div>`;
    const inN = document.createElement('input');
    inN.type = 'number';
    inN.min = '1';
    inN.step = '1';
    inN.placeholder = 'ÔºàÊú™ÂÖ•ÂäõÔºâ';
    inN.value = (r.N == null ? '' : String(r.N));
    fieldN.appendChild(inN);

    const fieldM = document.createElement('div');
    fieldM.className = 'field';
    fieldM.innerHTML = `<div class="label">M</div>`;
    const inM = document.createElement('input');
    inM.type = 'number';
    inM.min = '1';
    inM.step = '1';
    inM.placeholder = 'ÔºàÊú™ÂÖ•ÂäõÔºâ';
    inM.value = (r.M == null ? '' : String(r.M));
    fieldM.appendChild(inM);

    const btnAnim = document.createElement('button');
    btnAnim.className = 'iconBtn';
    btnAnim.title = '„Åì„ÅÆË°å„ÅÆ„Ç¢„Éã„É° ÂÜçÁîü/ÂÅúÊ≠¢';
    btnAnim.textContent = '‚ñ∂';

    const btnGear = document.createElement('button');
    btnGear.className = 'iconBtn';
    btnGear.title = 'Ë®≠ÂÆö';
    btnGear.textContent = '‚öô';

    const btnDel = document.createElement('button');
    btnDel.className = 'iconBtn';
    btnDel.title = 'ÂâäÈô§';
    btnDel.textContent = 'üóë';

    const meta = document.createElement('div');
    meta.className = 'rowMeta';

    function updateMeta(){
      const N = r.N, M = r.M;
      if (!Number.isInteger(N) || !Number.isInteger(M)){
        meta.textContent = `Êú™ÂÖ•ÂäõÔºàN,M„ÇíÂÖ•„Çå„Çã„Å®ÊèèÁîª„Åó„Åæ„ÅôÔºâ`;
        return;
      }
      if (N < 3){
        meta.textContent = `Ê≥®ÊÑè: N=${N} „ÅØÂ§öËßíÂΩ¢„Å´„Å™„Çä„Åæ„Åõ„ÇìÔºàN‚â•3Êé®Â•®Ôºâ`;
        return;
      }
      if (M < 1){
        meta.textContent = `Ê≥®ÊÑè: M „ÅØ 1 ‰ª•‰∏ä`;
        return;
      }
      const info = getCycleInfo(r);
      const sw = `<span class="swatch" style="background:${r.lineColor}"></span>`;
      meta.innerHTML =
        `start=${info.startN}, step=M mod N=${info.step}, gcd(N,M)=${info.d}, ÈñâË∑ØÈï∑L=${info.L}, time=${r.animTimeSec.toFixed(1)}s ${sw}`;
    }

    function stopGlobalIfNeeded(){
      if (globalPlaying){
        globalPlaying = false;
        btnToggleAll.textContent = "‚ñ∂ ÂÖ®„Ç¢„Éã„É°ÂÜçÁîü";
      }
    }

    function resetAnim(){
      r.animPlaying = false;
      r.animProgressEdges = 0.0;
      card._setAnimIcon();
    }

    function applyN(){
      const raw = inN.value.trim();
      if (raw === ''){
        r.N = null;
        resetAnim();
        stopGlobalIfNeeded();
        card._updateMeta();
        scheduleDraw();
        return;
      }
      const v = Math.floor(Number(raw));
      r.N = Number.isFinite(v) ? v : null;
      if (r.N != null && r.N < 1) r.N = 1;
      inN.value = (r.N == null ? '' : String(r.N));

      resetAnim();
      stopGlobalIfNeeded();
      card._updateMeta();
      scheduleDraw();
    }

    function applyM(){
      const raw = inM.value.trim();
      if (raw === ''){
        r.M = null;
        resetAnim();
        stopGlobalIfNeeded();
        card._updateMeta();
        scheduleDraw();
        return;
      }
      const v = Math.floor(Number(raw));
      r.M = Number.isFinite(v) ? v : null;
      if (r.M != null && r.M < 1) r.M = 1;
      inM.value = (r.M == null ? '' : String(r.M));

      resetAnim();
      stopGlobalIfNeeded();
      card._updateMeta();
      scheduleDraw();
    }

    inN.addEventListener('input', applyN);
    inM.addEventListener('input', applyM);
    inN.addEventListener('change', applyN);
    inM.addEventListener('change', applyM);

    btnAnim.addEventListener('click', () => {
      const info = getCycleInfo(r);
      const edges = info.edges;

      if (!info.valid || edges <= 0){
        r.animPlaying = false;
        r.animProgressEdges = 0.0;
        card._setAnimIcon();
        return;
      }

      const T = Math.max(0.2, Number(r.animTimeSec) || DEFAULT_ANIM_TIME);
      r.animSpeedEdgesPerSec = edges > 0 ? (edges / T) : 0.0;

      r.animPlaying = !r.animPlaying;
      if (r.animPlaying) r.animProgressEdges = 0.0;
      card._setAnimIcon();

      stopGlobalIfNeeded();
      scheduleDraw();
    });

    btnGear.addEventListener('click', () => openRowSettings(r, card));
    btnDel.addEventListener('click', () => {
      const i = rows.findIndex(x => x.id === r.id);
      if (i >= 0) rows.splice(i,1);
      card.remove();

      if (selectedRowId === r.id) selectedRowId = null;
      if (globalPlaying){
        globalPlaying = false;
        btnToggleAll.textContent = "‚ñ∂ ÂÖ®„Ç¢„Éã„É°ÂÜçÁîü";
      }
      scheduleDraw();
    });

    card._updateMeta = updateMeta;
    card._setAnimIcon = () => { btnAnim.textContent = r.animPlaying ? '‚è∏' : '‚ñ∂'; };

    card.appendChild(fieldN);
    card.appendChild(fieldM);
    card.appendChild(btnAnim);
    card.appendChild(btnGear);
    card.appendChild(btnDel);
    card.appendChild(meta);

    updateMeta();
    card._setAnimIcon();
    return card;
  }

  function addRow(initial){
    const r = Object.assign(newRowDefaults(), initial || {});
    const idx = rows.length;
    const base = palette[idx % palette.length];
    if (!initial || !initial.lineColor) r.lineColor = base;
    if (!initial || !initial.pointColor) r.pointColor = base;

    const t = Number(r.animTimeSec);
    r.animTimeSec = (Number.isFinite(t) && t >= 0.2) ? t : DEFAULT_ANIM_TIME;

    const ls = Math.floor(Number(r.labelSizePx));
    r.labelSizePx = (Number.isFinite(ls) && ls >= 8) ? ls : DEFAULT_LABEL_SIZE;

    rows.push(r);
    rowsEl.appendChild(createRowUI(r));

    if (globalPlaying){
      globalPlaying = false;
      btnToggleAll.textContent = "‚ñ∂ ÂÖ®„Ç¢„Éã„É°ÂÜçÁîü";
    }
    scheduleDraw();
  }

  // ===== Row settings modal =====
  let modalRow = null;
  let modalRowCard = null;

  function openRowSettings(r, card){
    modalRow = r;
    modalRowCard = card;
    rowModalTitle.textContent = `Ë®≠ÂÆö ${rowTitle(r)}`;

    optVisible.checked = r.visible;
    optShowPoints.checked = r.showPoints;
    optShowLabels.checked = r.showLabels;

    optLabelSize.value = String(r.labelSizePx);

    optLineColor.value = r.lineColor;
    optPointColor.value = r.pointColor;

    optAnimTime.value = String(Number(r.animTimeSec).toFixed(1));
    optStart.value = String(Number.isFinite(r.start) ? r.start : 0);

    rowModalOverlay.style.display = 'flex';
  }
  function closeRowSettings(){
    rowModalOverlay.style.display = 'none';
    modalRow = null;
    modalRowCard = null;
  }

  function syncRowModalToRow(){
    if (!modalRow) return;
    const r = modalRow;

    r.visible = optVisible.checked;
    r.showPoints = optShowPoints.checked;
    r.showLabels = optShowLabels.checked;

    {
      const v = Math.floor(Number(optLabelSize.value));
      r.labelSizePx = (Number.isFinite(v) && v >= 8) ? v : DEFAULT_LABEL_SIZE;
      optLabelSize.value = String(r.labelSizePx);
    }

    r.lineColor = optLineColor.value;
    r.pointColor = optPointColor.value;

    {
      const v = Number(optAnimTime.value);
      r.animTimeSec = (Number.isFinite(v) && v >= 0.2) ? v : DEFAULT_ANIM_TIME;
      optAnimTime.value = String(r.animTimeSec.toFixed(1));
    }
    {
      const v = Math.floor(Number(optStart.value));
      r.start = Number.isFinite(v) ? v : 0;
      optStart.value = String(r.start);
    }

    r.animPlaying = false;
    r.animProgressEdges = 0.0;

    if (globalPlaying){
      globalPlaying = false;
      btnToggleAll.textContent = "‚ñ∂ ÂÖ®„Ç¢„Éã„É°ÂÜçÁîü";
    }

    if (modalRowCard && modalRowCard._updateMeta) modalRowCard._updateMeta();
    if (modalRowCard && modalRowCard._setAnimIcon) modalRowCard._setAnimIcon();

    scheduleDraw();
  }

  rowModalClose.addEventListener('click', closeRowSettings);
  rowModalOverlay.addEventListener('click', (e) => {
    if (e.target === rowModalOverlay) closeRowSettings();
  });
  [optVisible,optShowPoints,optShowLabels,optLabelSize,optLineColor,optPointColor,optAnimTime,optStart].forEach(el => {
    el.addEventListener('input', syncRowModalToRow);
    el.addEventListener('change', syncRowModalToRow);
  });

  // ===== Global settings modal =====
  function openGlobalSettings(){
    optCircleColor.value = themeState.circleHex;
    optTheme.value = themeState.theme;
    globalModalOverlay.style.display = 'flex';
  }
  function closeGlobalSettings(){
    globalModalOverlay.style.display = 'none';
  }

  globalModalClose.addEventListener('click', closeGlobalSettings);
  globalModalOverlay.addEventListener('click', (e) => {
    if (e.target === globalModalOverlay) closeGlobalSettings();
  });

  // Theme state
  const themeState = {
    theme: 'dark',
    circleHex: '#b0b0b0',
  };

  function hexToRgba(hex, a){
    const h = hex.replace('#','').trim();
    const v = h.length === 3
      ? h.split('').map(ch => ch+ch).join('')
      : h.padStart(6,'0').slice(0,6);
    const r = parseInt(v.slice(0,2),16);
    const g = parseInt(v.slice(2,4),16);
    const b = parseInt(v.slice(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  function applyTheme(){
    const root = document.documentElement.style;

    if (themeState.theme === 'light'){
      root.setProperty('--bg', '#ffffff');
      root.setProperty('--bgImg', 'none');
      root.setProperty('--fg', '#111827');
      root.setProperty('--muted', '#374151');

      root.setProperty('--panel', '#ffffff');
      root.setProperty('--panelSolid', '#ffffff');
      root.setProperty('--controlsBg', '#ffffff');
      root.setProperty('--boxBg', '#ffffff');
      root.setProperty('--cardBg', '#ffffff');

      root.setProperty('--border', 'rgba(0,0,0,.12)');
      root.setProperty('--border2', 'rgba(0,0,0,.16)');

      root.setProperty('--btnBg', '#ffffff');
      root.setProperty('--btnBgHover', 'rgba(0,0,0,.06)');
      root.setProperty('--btnBorder', 'rgba(0,0,0,.30)');

      root.setProperty('--overlayBg', 'rgba(0,0,0,.25)');
      root.setProperty('--modalBg', '#ffffff');
      root.setProperty('--modalBorder', 'rgba(0,0,0,.18)');
      root.setProperty('--modalBodyBg', '#ffffff');
      root.setProperty('--modalRowBg', '#ffffff');
      root.setProperty('--modalRowBorder', 'rgba(0,0,0,.12)');
      root.setProperty('--inputBg', '#ffffff');
      root.setProperty('--shadow', '0 20px 60px rgba(0,0,0,.18)');

      root.setProperty('--canvasBg', '#ffffff');

      root.setProperty('--hudBg', 'rgba(255,255,255,.92)');
      root.setProperty('--hudFg', 'rgba(17,24,39,.98)');
      root.setProperty('--hudBorder', 'rgba(0,0,0,.20)');

      root.setProperty('--circle', hexToRgba(themeState.circleHex, 0.75));
    } else {
      root.setProperty('--bg', '#0b0f17');
      root.setProperty('--bgImg', 'radial-gradient(1200px 700px at 30% 20%, rgba(17,24,39,1), rgba(5,7,11,1))');
      root.setProperty('--fg', '#e5e7eb');
      root.setProperty('--muted', '#9ca3af');

      root.setProperty('--panel', 'rgba(17,24,39,.86)');
      root.setProperty('--panelSolid', '#111827');
      root.setProperty('--border', 'rgba(255,255,255,.10)');
      root.setProperty('--border2', 'rgba(255,255,255,.14)');

      root.setProperty('--btnBg', 'rgba(255,255,255,.06)');
      root.setProperty('--btnBgHover', 'rgba(255,255,255,.10)');
      root.setProperty('--btnBorder', 'rgba(255,255,255,.14)');

      root.setProperty('--controlsBg', 'linear-gradient(to bottom, var(--panelSolid), rgba(17,24,39,.60))');
      root.setProperty('--boxBg', 'rgba(0,0,0,.18)');
      root.setProperty('--cardBg', 'rgba(255,255,255,.04)');

      root.setProperty('--overlayBg', 'rgba(0,0,0,.55)');
      root.setProperty('--modalBg', 'rgba(17,24,39,.96)');
      root.setProperty('--modalBorder', 'rgba(255,255,255,.10)');
      root.setProperty('--modalBodyBg', 'rgba(0,0,0,.18)');
      root.setProperty('--modalRowBg', 'rgba(255,255,255,.03)');
      root.setProperty('--modalRowBorder', 'rgba(255,255,255,.08)');
      root.setProperty('--inputBg', 'rgba(0,0,0,.25)');
      root.setProperty('--shadow', '0 20px 60px rgba(0,0,0,.45)');

      root.setProperty('--canvasBg', 'rgba(0,0,0,0)');

      root.setProperty('--hudBg', 'rgba(0,0,0,.55)');
      root.setProperty('--hudFg', 'rgba(255,255,255,.92)');
      root.setProperty('--hudBorder', 'rgba(255,255,255,.18)');

      root.setProperty('--circle', hexToRgba(themeState.circleHex, 0.75));
    }

    scheduleDraw();
  }

  optTheme.addEventListener('change', () => {
    themeState.theme = optTheme.value;
    applyTheme();
  });
  optCircleColor.addEventListener('input', () => {
    themeState.circleHex = optCircleColor.value;
    applyTheme();
  });

  // ===== Drawing =====
  function clearAndFillCanvas(){
    const fill = (themeState.theme === 'dark') ? '#0b0f17' : '#ffffff';
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = fill;
    ctx.fillRect(0,0,cv.width,cv.height);
  }

  function drawCircle(cx, cy, r){
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, TAU);
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--circle').trim();
    ctx.lineWidth = Math.max(1, cv.width * 0.002);
    ctx.stroke();
    ctx.restore();
  }

  function getLabelColor(){
    return (themeState.theme === 'light') ? 'rgba(17,24,39,0.95)' : 'rgba(255,255,255,0.92)';
  }
  function getLabelStrokeColor(){
    return (themeState.theme === 'light') ? 'rgba(255,255,255,0.92)' : 'rgba(0,0,0,0.78)';
  }

  function drawRow(r, cx, cy, radius){
    if (!r.visible) return;

    const info = getCycleInfo(r);
    if (!info.valid) return;

    const N = r.N;
    const pts = pointsOnCircle(N, cx, cy, radius);

    // vertices
    if (r.showPoints && N >= 1){
      ctx.save();
      const dot = Math.max(2, cv.width * 0.004) / view.scale;
      for(let i=0;i<N;i++){
        ctx.beginPath();
        ctx.arc(pts[i].x, pts[i].y, dot, 0, TAU);
        ctx.fillStyle = r.pointColor;
        ctx.globalAlpha = 0.80;
        ctx.fill();
        ctx.globalAlpha = 1.0;
      }
      ctx.restore();
    }

    if (r.showLabels && N >= 1){
      ctx.save();
      const labelColor = getLabelColor();
      const strokeColor = getLabelStrokeColor();

      const size = Math.max(8, (Number(r.labelSizePx) || DEFAULT_LABEL_SIZE)) / view.scale;

      ctx.font = `700 ${size}px "KaTeX_Main","KaTeX_Math","Times New Roman",serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const off = Math.max(14, (cv.width * 0.022)) / view.scale;

      for(let i=0;i<N;i++){
        const vx = pts[i].x - cx, vy = pts[i].y - cy;
        const len = Math.hypot(vx,vy) || 1;
        const tx = pts[i].x + (vx/len)*off;
        const ty = pts[i].y + (vy/len)*off;

        ctx.lineWidth = Math.max(2.5, size * 0.22);
        ctx.strokeStyle = strokeColor;
        ctx.strokeText(String(i), tx, ty);

        ctx.fillStyle = labelColor;
        ctx.fillText(String(i), tx, ty);
      }
      ctx.restore();
    }

    const totalEdges = info.edges;
    if (totalEdges <= 0) return;

    const p = r.animPlaying
      ? Math.max(0, Math.min(totalEdges, r.animProgressEdges))
      : totalEdges;

    const whole = Math.floor(p);
    const frac  = p - whole;
    if (whole <= 0 && frac <= 0) return;

    const cycle = info.cycle;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(pts[cycle[0]].x, pts[cycle[0]].y);

    for(let i=1; i<=whole; i++){
      ctx.lineTo(pts[cycle[i]].x, pts[cycle[i]].y);
    }

    if (whole < totalEdges && frac > 0){
      const aIdx = cycle[whole];
      const bIdx = cycle[whole + 1];
      const ax = pts[aIdx].x, ay = pts[aIdx].y;
      const bx = pts[bIdx].x, by = pts[bIdx].y;
      const mx = ax + (bx - ax) * frac;
      const my = ay + (by - ay) * frac;
      ctx.lineTo(mx, my);
    }

    ctx.strokeStyle = r.lineColor;
    ctx.globalAlpha = 0.95;
    ctx.lineWidth = Math.max(1.5, cv.width * 0.0045) / view.scale;
    ctx.lineJoin = 'round';
    ctx.lineCap  = 'round';
    ctx.stroke();
    ctx.globalAlpha = 1.0;

    if (selectedRowId === r.id){
      ctx.globalAlpha = 0.18;
      ctx.lineWidth = (Math.max(8, cv.width * 0.012) / view.scale);
      ctx.strokeStyle = r.lineColor;
      ctx.stroke();
      ctx.globalAlpha = 1.0;
    }

    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawHUD(){
    if (selectedRowId == null) return;
    const r = rows.find(x => x.id === selectedRowId);
    if (!r) return;

    const info = getCycleInfo(r);
    if (!info.valid) return;

    const bg = getComputedStyle(document.documentElement).getPropertyValue('--hudBg').trim();
    const fg = getComputedStyle(document.documentElement).getPropertyValue('--hudFg').trim();
    const bd = getComputedStyle(document.documentElement).getPropertyValue('--hudBorder').trim();

    const x = 12, y = 12;

    const fontSize  = Math.min(110, Math.max(34, cv.width * 0.060));
    const pad = Math.round(fontSize * 0.35);

    const texFont = `"KaTeX_Main","KaTeX_Math","Times New Roman",serif`;
    const line1 = `N=${r.N},  M=${r.M}`;

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);

    ctx.font = `700 ${fontSize}px ${texFont}`;
    const w1 = ctx.measureText(line1).width;

    const boxW = w1 + pad*2 + 10;
    const boxH = pad*2 + fontSize + Math.round(fontSize*0.25);

    roundRect(ctx, x, y, boxW, boxH, 14);
    ctx.fillStyle = bg;
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = bd;
    ctx.stroke();

    ctx.fillStyle = r.lineColor;
    ctx.globalAlpha = 0.88;
    roundRect(ctx, x+8, y+8, Math.max(12, fontSize*0.16), boxH-16, 10);
    ctx.fill();
    ctx.globalAlpha = 1.0;

    ctx.fillStyle = fg;
    ctx.font = `700 ${fontSize}px ${texFont}`;
    ctx.fillText(line1, x + pad + 18, y + pad + fontSize - 4);

    ctx.restore();
  }

  function drawAll(){
    resizeCanvasToDisplaySize();
    clearAndFillCanvas();

    const cx = cv.width/2;
    const cy = cv.height/2 + centerYOffsetPx;

    const baseRadius = Math.min(cv.width, cv.height) * 0.82 * 0.5 * 0.9;

    ctx.save();
    ctx.translate(cx + view.panX, cy + view.panY);
    ctx.scale(view.scale, view.scale);

    drawCircle(0, 0, baseRadius);
    for(const r of rows){
      drawRow(r, 0, 0, baseRadius);
    }
    ctx.restore();

    drawHUD();
  }

  function updateGlobalInfo(){
    const total = rows.length;
    const playing = rows.filter(r => r.animPlaying).length;

    globalInfoEl.innerHTML = `
      <b>Ë°®Á§∫Êï∞</b>: ${total}<br/>
      <b>„Ç¢„Éã„É°‰∏≠</b>: ${playing} / ${total}<br/>
    `;
  }

  // ===== Animation tick =====
  function anyAnimationPlaying(){
    return rows.some(r => r.animPlaying);
  }

  function tick(t){
    if (lastT == null) lastT = t;
    const dt = (t - lastT) / 1000;
    lastT = t;

    for(const r of rows){
      if (!r.animPlaying) continue;

      const info = getCycleInfo(r);
      const edges = info.edges;
      if (!info.valid || edges <= 0){
        r.animPlaying = false;
        continue;
      }

      r.animProgressEdges += (r.animSpeedEdgesPerSec * dt);

      if (r.animProgressEdges >= edges){
        r.animProgressEdges = edges;
        r.animPlaying = false;

        const card = rowsEl.querySelector(`.rowCard[data-row-id="${r.id}"]`);
        if (card && card._setAnimIcon) card._setAnimIcon();
      }
    }

    drawAll();
    updateGlobalInfo();

    if (anyAnimationPlaying()){
      rafId = requestAnimationFrame(tick);
    } else {
      rafId = null;
      lastT = null;

      if (globalPlaying){
        globalPlaying = false;
        btnToggleAll.textContent = "‚ñ∂ ÂÖ®„Ç¢„Éã„É°ÂÜçÁîü";
      }
    }
  }

  function scheduleDraw(){
    drawAll();
    updateGlobalInfo();

    if (anyAnimationPlaying() && !rafId){
      rafId = requestAnimationFrame(tick);
    }
    if (!anyAnimationPlaying() && rafId){
      cancelAnimationFrame(rafId);
      rafId = null;
      lastT = null;
    }
  }

  // ===== Canvas interactions: zoom/pan + select =====
  function getCanvasPixelPos(evt){
    const rect = cv.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const x = (evt.clientX - rect.left) * dpr;
    const y = (evt.clientY - rect.top) * dpr;
    return { x, y };
  }

  function screenToWorld(px, py){
    const cx = cv.width/2;
    const cy = cv.height/2 + centerYOffsetPx;
    const wx = (px - cx - view.panX) / view.scale;
    const wy = (py - cy - view.panY) / view.scale;
    return { x: wx, y: wy };
  }

  function distPointToSegment(px, py, ax, ay, bx, by){
    const vx = bx - ax, vy = by - ay;
    const wx = px - ax, wy = py - ay;
    const vv = vx*vx + vy*vy;
    if (vv === 0) return Math.hypot(px-ax, py-ay);
    let t = (wx*vx + wy*vy) / vv;
    t = Math.max(0, Math.min(1, t));
    const cx = ax + t*vx;
    const cy = ay + t*vy;
    return Math.hypot(px-cx, py-cy);
  }

  function rowHitTest(worldX, worldY){
    const baseRadius = Math.min(cv.width, cv.height) * 0.82 * 0.5 * 0.9;
    const best = { id: null, d: Infinity };

    for (const r of rows){
      if (!r.visible) continue;

      const info = getCycleInfo(r);
      if (!info.valid) continue;
      if (info.edges <= 0) continue;

      const N = r.N;
      const cycle = info.cycle;
      const pts = pointsOnCircle(N, 0, 0, baseRadius);

      for (let i=0;i<cycle.length-1;i++){
        const a = pts[cycle[i]];
        const b = pts[cycle[i+1]];
        const d = distPointToSegment(worldX, worldY, a.x, a.y, b.x, b.y);
        if (d < best.d){
          best.d = d;
          best.id = r.id;
        }
      }
    }

    const thresholdPx = 12;
    const thresholdWorld = thresholdPx / view.scale;
    if (best.id != null && best.d <= thresholdWorld) return best.id;
    return null;
  }

  let isDragging = false;
  let dragMoved = false;
  let lastX = 0, lastY = 0;

  cv.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragMoved = false;
    const p = getCanvasPixelPos(e);
    lastX = p.x; lastY = p.y;
    cv.classList.add('dragging');
  });

  window.addEventListener('mouseup', () => {
    isDragging = false;
    cv.classList.remove('dragging');
  });

  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const p = getCanvasPixelPos(e);
    const dx = p.x - lastX;
    const dy = p.y - lastY;

    if (Math.hypot(dx,dy) > 2) dragMoved = true;

    view.panX += dx;
    view.panY += dy;
    lastX = p.x; lastY = p.y;
    scheduleDraw();
  });

  cv.addEventListener('wheel', (e) => {
    e.preventDefault();

    const { x: mx, y: my } = getCanvasPixelPos(e);

    const cx = cv.width / 2;
    const cy = cv.height / 2 + centerYOffsetPx;

    const oldScale = view.scale;
    const zoomFactor = Math.exp((-e.deltaY) * 0.0012);
    let newScale = oldScale * zoomFactor;
    newScale = Math.max(view.minScale, Math.min(view.maxScale, newScale));

    const worldX = (mx - cx - view.panX) / oldScale;
    const worldY = (my - cy - view.panY) / oldScale;

    view.panX = (mx - cx) - newScale * worldX;
    view.panY = (my - cy) - newScale * worldY;
    view.scale = newScale;

    scheduleDraw();
  }, { passive:false });

  cv.addEventListener('dblclick', () => {
    resetView();
    scheduleDraw();
  });

  cv.addEventListener('click', (e) => {
    if (dragMoved) return;
    const p = getCanvasPixelPos(e);
    const w = screenToWorld(p.x, p.y);
    selectedRowId = rowHitTest(w.x, w.y);
    scheduleDraw();
  });

  // ===== Controls =====
  btnAdd.addEventListener('click', () => addRow());

  btnToggleAll.addEventListener('click', () => {
    globalPlaying = !globalPlaying;

    if (globalPlaying){
      prepareSpeedsForAll();
      for (const r of rows){
        const info = getCycleInfo(r);
        r.animPlaying = info.valid && info.edges > 0;
        r.animProgressEdges = 0.0;

        const card = rowsEl.querySelector(`.rowCard[data-row-id="${r.id}"]`);
        if (card && card._setAnimIcon) card._setAnimIcon();
      }
      btnToggleAll.textContent = "‚è∏ ÂÖ®„Ç¢„Éã„É°ÂÅúÊ≠¢";
      scheduleDraw();
    } else {
      for (const r of rows){
        r.animPlaying = false;
        const card = rowsEl.querySelector(`.rowCard[data-row-id="${r.id}"]`);
        if (card && card._setAnimIcon) card._setAnimIcon();
      }
      btnToggleAll.textContent = "‚ñ∂ ÂÖ®„Ç¢„Éã„É°ÂÜçÁîü";
      scheduleDraw();
    }
  });

  btnSave.addEventListener('click', () => {
    const url = cv.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = `NM-polygons.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

  // „É™„Çª„ÉÉ„ÉàÔºöË®≠ÂÆö„Éú„Çø„É≥„Åß„ÅÆ„ÅøÂ§âÊõ¥
  btnReset.addEventListener('click', () => {
    globalPlaying = false;
    btnToggleAll.textContent = "‚ñ∂ ÂÖ®„Ç¢„Éã„É°ÂÜçÁîü";
    if (rafId){
      cancelAnimationFrame(rafId);
      rafId = null;
      lastT = null;
    }

    rows.splice(0, rows.length);
    rowsEl.innerHTML = '';
    selectedRowId = null;
    nextId = 1;

    resetView();

    applyTheme();

    addRow({ N: null, M: null, start: DEFAULT_START, animTimeSec: DEFAULT_ANIM_TIME });
    scheduleDraw();
  });

  btnOpenGlobal.addEventListener('click', () => openGlobalSettings());

  // ===== Init =====
  window.addEventListener('resize', () => scheduleDraw());

  applyTheme();
  addRow({ N: null, M: null, start: DEFAULT_START, animTimeSec: DEFAULT_ANIM_TIME });

})();
</script>
</body>
</html>

